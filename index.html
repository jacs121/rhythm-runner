<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Rhythm Obstacle Runner - Mobile Optimized</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            touch-action: none;
            overscroll-behavior: contain;
            position: fixed;
            /* Ensure full coverage on all devices */
            -webkit-overflow-scrolling: touch;
        }

        #gameCanvas {
            display: block;
            background: #0a0a1a;
            touch-action: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            /* Ensure no scaling issues or cutoffs */
            width: 100vw;
            height: 100vh;
            max-width: 100%;
            max-height: 100%;
            /* Prevent iOS Safari bouncing */
            -webkit-transform: translateZ(0);
        }

        /* Mobile Controls - Enhanced Design */
        .mobile-controls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            z-index: 1000;
            pointer-events: none;
            gap: 15px;
            max-width: 100vw;
            box-sizing: border-box;
            padding: 0 10px;
        }

        /* Left side controls (movement) */
        .movement-controls {
            display: grid;
            grid-template-columns: repeat(3, 70px);
            grid-template-rows: repeat(3, 70px);
            gap: 10px;
            float: left;
            pointer-events: auto;
        }

        /* Right side controls (action buttons) */
        .action-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            float: right;
            pointer-events: auto;
        }

        .mobile-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            border: 3px solid rgba(0, 255, 255, 0.6);
            color: #ffffff;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            touch-action: manipulation;
            transition: all 0.1s ease;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .mobile-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle, transparent 30%, rgba(0, 255, 255, 0.1) 100%);
            opacity: 0;
            transition: opacity 0.1s ease;
        }

        .mobile-btn:active::before {
            opacity: 1;
        }

        .mobile-btn.pressed {
            background: rgba(0, 255, 255, 0.3);
            border-color: #00ffff;
            transform: scale(0.95);
            box-shadow: 0 4px 8px rgba(0, 255, 255, 0.3);
        }

        .mobile-btn.action {
            width: 80px;
            height: 80px;
            border-radius: 15px;
            font-size: 16px;
            border-width: 3px;
        }

        .mobile-btn.dash {
            background: rgba(255, 200, 50, 0.2);
            border-color: rgba(255, 200, 50, 0.8);
        }

        .mobile-btn.dash.pressed {
            background: rgba(255, 200, 50, 0.4);
            border-color: #ffc800;
        }

        .mobile-btn.pause {
            background: rgba(255, 100, 100, 0.2);
            border-color: rgba(255, 100, 100, 0.8);
        }

        .mobile-btn.pause.pressed {
            background: rgba(255, 100, 100, 0.4);
            border-color: #ff6464;
        }

        /* Mobile detection and responsive design - more specific */
        @media (max-width: 1024px) and (hover: none) and (pointer: coarse) {
            .mobile-controls {
                display: block;
            }
            
            /* Portrait orientation notice for gameplay */
            .portrait-notice {
                display: none;
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.9);
                color: #00ffff;
                padding: 20px;
                border-radius: 10px;
                border: 2px solid #00ffff;
                text-align: center;
                z-index: 10000;
                font-size: 18px;
                font-weight: bold;
            }
            
            /* Show notice in portrait during gameplay */
            @media (orientation: portrait) {
                .gameplay .portrait-notice {
                    display: block;
                }
            }
            
            .mobile-btn {
                font-size: 18px;
            }
            
            .mobile-btn.action {
                font-size: 14px;
                width: 70px;
                height: 70px;
            }
            
            /* Ensure canvas fills screen properly */
            html, body {
                margin: 0;
                padding: 0;
            }
        }

        /* Landscape/Wide screen optimizations */
        @media (orientation: landscape) and (max-height: 600px) {
            .mobile-controls {
                bottom: 10px;
                left: 10px;
                right: 10px;
            }
            
            .movement-controls {
                grid-template-columns: repeat(3, 50px);
                grid-template-rows: repeat(3, 50px);
                gap: 6px;
            }
            
            .mobile-btn {
                width: 50px;
                height: 50px;
                font-size: 16px;
            }
            
            .mobile-btn.action {
                width: 60px;
                height: 60px;
                font-size: 12px;
            }
        }

        /* Wide screen (tablets/laptops) */
        @media (min-width: 768px) and (orientation: landscape) {
            .mobile-controls {
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                max-width: 600px;
            }
            
            .movement-controls {
                grid-template-columns: repeat(3, 80px);
                grid-template-rows: repeat(3, 80px);
                gap: 12px;
            }
            
            .mobile-btn {
                width: 80px;
                height: 80px;
                font-size: 24px;
            }
            
            .mobile-btn.action {
                width: 100px;
                height: 80px;
                font-size: 18px;
                border-radius: 15px;
            }
        }

        /* For very small screens */
        @media (max-width: 480px) {
            .mobile-controls {
                bottom: 15px;
                left: 15px;
                right: 15px;
            }
            
            .movement-controls {
                grid-template-columns: repeat(3, 60px);
                grid-template-rows: repeat(3, 60px);
                gap: 8px;
            }
            
            .mobile-btn {
                width: 60px;
                height: 60px;
                font-size: 18px;
            }
            
            .mobile-btn.action {
                width: 70px;
                height: 70px;
                font-size: 12px;
            }
        }

        /* Loading animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #00ffff;
            animation: spin 1s ease-in-out infinite;
            vertical-align: middle;
            margin-right: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Orientation handling */
        @media screen and (orientation: landscape) and (max-height: 500px) {
            .mobile-controls {
                bottom: 10px;
                left: 10px;
                right: 10px;
            }
            
            .movement-controls {
                grid-template-columns: repeat(3, 50px);
                grid-template-rows: repeat(3, 50px);
                gap: 6px;
            }
            
            .mobile-btn {
                width: 50px;
                height: 50px;
                font-size: 16px;
            }
            
            .mobile-btn.action {
                width: 60px;
                height: 60px;
                font-size: 11px;
            }
        }

        /* Ultra-wide screens (21:9, 32:9, etc.) */
        @media (min-aspect-ratio: 2/1) and (min-width: 1200px) {
            .mobile-controls {
                left: 50%;
                transform: translateX(-50%);
                max-width: 800px;
                gap: 15px;
            }
            
            .movement-controls {
                grid-template-columns: repeat(3, 80px);
                grid-template-rows: repeat(3, 80px);
                gap: 10px;
            }
            
            .mobile-btn {
                width: 80px;
                height: 80px;
                font-size: 24px;
            }
            
            .mobile-btn.action {
                width: 100px;
                height: 80px;
                font-size: 16px;
                border-radius: 15px;
            }
        }

        /* Standard desktop displays */
        @media (min-width: 1024px) and (orientation: landscape) {
            .mobile-controls {
                bottom: 30px;
                left: 50%;
                transform: translateX(-50%);
                max-width: 600px;
            }
            
            .movement-controls {
                grid-template-columns: repeat(3, 70px);
                grid-template-rows: repeat(3, 70px);
                gap: 12px;
            }
            
            .mobile-btn {
                width: 70px;
                height: 70px;
                font-size: 20px;
            }
            
            .mobile-btn.action {
                width: 90px;
                height: 70px;
                font-size: 16px;
                border-radius: 12px;
            }
        }

        /* Very small phones */
        @media (max-width: 360px) {
            .mobile-controls {
                bottom: 10px;
                left: 10px;
                right: 10px;
            }
            
            .movement-controls {
                grid-template-columns: repeat(3, 50px);
                grid-template-rows: repeat(3, 50px);
                gap: 5px;
            }
            
            .mobile-btn {
                width: 50px;
                height: 50px;
                font-size: 14px;
            }
            
            .mobile-btn.action {
                width: 60px;
                height: 50px;
                font-size: 10px;
            }
        }

        /* High-DPI displays - reduce button sizes slightly */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            .mobile-btn {
                transform: scale(0.9);
            }
            
            .mobile-btn.action {
                transform: scale(0.9);
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <!-- Mobile Controls -->
    <div class="mobile-controls">
        <!-- Portrait orientation notice for gameplay -->
        <div class="portrait-notice">
            üîÑ Please rotate your device to landscape for the best gameplay experience!
        </div>
        
        <!-- Movement Controls (Left Side) -->
        <div class="movement-controls">
            <div></div>
            <button class="mobile-btn" id="upBtn" style="grid-column: 2; grid-row: 1;">‚Üë</button>
            <div></div>
            
            <button class="mobile-btn" id="leftBtn" style="grid-column: 1; grid-row: 2;">‚Üê</button>
            <div></div>
            <button class="mobile-btn" id="rightBtn" style="grid-column: 3; grid-row: 2;">‚Üí</button>
            
            <div></div>
            <button class="mobile-btn" id="downBtn" style="grid-column: 2; grid-row: 3;">‚Üì</button>
            <div></div>
        </div>

        <!-- Action Controls (Right Side) -->
        <div class="action-controls">
            <button class="mobile-btn dash action" id="dashBtn">DASH</button>
            <button class="mobile-btn pause action" id="pauseBtn">‚è∏</button>
        </div>
    </div>

    <script>
        // ==================== ENHANCED BEAT DETECTION ENGINE ====================
        class EnhancedBeatDetector {
            constructor() {
                this.audioContext = null;
                this.audioBuffer = null;
                this.sampleRate = 0;
            }

            async analyzeAudio(audioBuffer) {
                this.audioBuffer = audioBuffer;
                this.sampleRate = audioBuffer.sampleRate;
                
                const duration = audioBuffer.duration;
                const obstacles = [];
                
                const channelData = audioBuffer.getChannelData(0);
                
                // VERY STRICT laser detection
                const laserObstacles = this.detectLaserBeats(channelData, duration);
                const squareObstacles = this.detectSquareBeats(channelData, duration);
                const triangleObstacles = this.detectTriangleBeats(channelData, duration);
                
                const allObstacles = [
                    ...laserObstacles,
                    ...squareObstacles,
                    ...triangleObstacles
                ].sort((a, b) => a.time - b.time);
                
                return this.filterObstacles(allObstacles);
            }

            detectLaserBeats(channelData, duration) {
                const obstacles = [];
                const chunkDuration = 0.15;
                const chunkSize = Math.floor(this.sampleRate * chunkDuration);
                const numChunks = Math.floor(channelData.length / chunkSize);
                
                for (let i = 0; i < numChunks; i++) {
                    const startSample = i * chunkSize;
                    const endSample = Math.min(startSample + chunkSize, channelData.length);
                    const timestamp = (startSample / this.sampleRate) * 1000;
                    
                    const transient = this.detectTransient(channelData, startSample, endSample);
                    const highFreq = this.getHighFrequencyEnergy(channelData, startSample, endSample);
                    
                    if (transient > 0.5 && highFreq > 0.25) {
                        obstacles.push({
                            time: timestamp,
                            type: 'laser',
                            energy: transient
                        });
                    }
                }
                
                return obstacles;
            }

            detectSquareBeats(channelData, duration) {
                const obstacles = [];
                const chunkDuration = 0.05;
                const chunkSize = Math.floor(this.sampleRate * chunkDuration);
                const numChunks = Math.floor(channelData.length / chunkSize);
                
                for (let i = 0; i < numChunks; i++) {
                    const startSample = i * chunkSize;
                    const endSample = Math.min(startSample + chunkSize, channelData.length);
                    const timestamp = (startSample / this.sampleRate) * 1000;
                    
                    const energy = this.calculateEnergy(channelData, startSample, endSample);
                    const midEnergy = this.getMidFrequencyEnergy(channelData, startSample, endSample);
                    
                    if (this.isEnergySpike(energy, i, channelData, chunkSize) && midEnergy > 0.05) {
                        obstacles.push({
                            time: timestamp,
                            type: 'square',
                            energy: energy
                        });
                    }
                }
                
                return obstacles;
            }

            detectTriangleBeats(channelData, duration) {
                const obstacles = [];
                const chunkDuration = 0.08;
                const chunkSize = Math.floor(this.sampleRate * chunkDuration);
                const numChunks = Math.floor(channelData.length / chunkSize);
                
                for (let i = 0; i < numChunks; i++) {
                    const startSample = i * chunkSize;
                    const endSample = Math.min(startSample + chunkSize, channelData.length);
                    const timestamp = (startSample / this.sampleRate) * 1000;
                    
                    const lowEnergy = this.getLowFrequencyEnergy(channelData, startSample, endSample);
                    const bassHit = this.detectBassHit(channelData, startSample, endSample);
                    
                    if (bassHit && lowEnergy > 0.12) {
                        obstacles.push({
                            time: timestamp,
                            type: 'triangle',
                            energy: lowEnergy
                        });
                    }
                }
                
                return obstacles;
            }

            detectTransient(data, start, end) {
                let maxChange = 0;
                for (let i = start + 1; i < end; i++) {
                    const change = Math.abs(data[i] - data[i - 1]);
                    maxChange = Math.max(maxChange, change);
                }
                return maxChange;
            }

            detectBassHit(data, start, end) {
                let sustained = 0;
                const threshold = 0.1;
                for (let i = start; i < end; i++) {
                    if (Math.abs(data[i]) > threshold) sustained++;
                }
                return (sustained / (end - start)) > 0.4;
            }

            getHighFrequencyEnergy(data, start, end) {
                let sum = 0;
                for (let i = start; i < end; i += 2) {
                    sum += Math.abs(data[i]);
                }
                return sum / ((end - start) / 2);
            }

            getMidFrequencyEnergy(data, start, end) {
                let sum = 0;
                for (let i = start; i < end; i += 4) {
                    sum += Math.abs(data[i]);
                }
                return sum / ((end - start) / 4);
            }

            getLowFrequencyEnergy(data, start, end) {
                let sum = 0;
                for (let i = start; i < end; i += 8) {
                    sum += Math.abs(data[i]);
                }
                return sum / ((end - start) / 8);
            }

            calculateEnergy(data, start, end) {
                let sum = 0;
                for (let i = start; i < end; i++) {
                    sum += data[i] * data[i];
                }
                return sum / (end - start);
            }

            isEnergySpike(energy, index, channelData, chunkSize) {
                const windowSize = 20;
                const startIdx = Math.max(0, index - windowSize);
                const endIdx = Math.min(index + windowSize, Math.floor(channelData.length / chunkSize));
                
                let avgEnergy = 0;
                let count = 0;
                
                for (let i = startIdx; i < endIdx; i++) {
                    const chunkStart = i * chunkSize;
                    const chunkEnd = Math.min(chunkStart + chunkSize, channelData.length);
                    avgEnergy += this.calculateEnergy(channelData, chunkStart, chunkEnd);
                    count++;
                }
                
                avgEnergy /= count;
                return energy > avgEnergy * 1.6 && energy > 0.008;
            }

            filterObstacles(obstacles) {
                const filtered = [];
                const minGap = 250;
                const minLaserGap = 2500;
                let lastLaserTime = -10000;
                
                for (let i = 0; i < obstacles.length; i++) {
                    const timeSinceLastObstacle = filtered.length === 0 ? Infinity : 
                        obstacles[i].time - filtered[filtered.length - 1].time;
                    const timeSinceLastLaser = obstacles[i].time - lastLaserTime;
                    
                    if (obstacles[i].type === 'laser') {
                        if (timeSinceLastObstacle >= minGap && timeSinceLastLaser >= minLaserGap) {
                            filtered.push(obstacles[i]);
                            lastLaserTime = obstacles[i].time;
                        }
                    } else {
                        if (timeSinceLastObstacle >= minGap) {
                            filtered.push(obstacles[i]);
                        }
                    }
                }
                
                return filtered;
            }
        }

        // ==================== DIFFICULTY SETTINGS ====================
        const DIFFICULTY_CONFIGS = {
            easy: {
                name: 'Easy',
                obstacleSpeedMultiplier: 0.6,
                spawnRateMultiplier: 0.6,
                damageMultiplier: 0.7,
                warningDuration: 2500,
                playerSpeed: 5
            },
            medium: {
                name: 'Medium',
                obstacleSpeedMultiplier: 1.0,
                spawnRateMultiplier: 1.0,
                damageMultiplier: 1.0,
                warningDuration: 2000,
                playerSpeed: 6
            },
            hard: {
                name: 'Hard',
                obstacleSpeedMultiplier: 1.2,
                spawnRateMultiplier: 1.3,
                damageMultiplier: 1.3,
                warningDuration: 1500,
                playerSpeed: 7
            },
            epic: {
                name: 'Epic Gamer',
                obstacleSpeedMultiplier: 1.6,
                spawnRateMultiplier: 1.6,
                damageMultiplier: 1.5,
                warningDuration: 1000,
                playerSpeed: 8
            }
        };

        // ==================== UI RENDERER ====================
        class UIRenderer {
            constructor(ctx, canvas) {
                this.ctx = ctx;
                this.canvas = canvas;
            }

            drawButton(x, y, width, height, text, highlighted = false) {
                this.ctx.save();
                
                // Button background
                if (highlighted) {
                    const gradient = this.ctx.createLinearGradient(x, y, x, y + height);
                    gradient.addColorStop(0, 'rgba(102, 126, 234, 0.9)');
                    gradient.addColorStop(1, 'rgba(118, 75, 162, 0.9)');
                    this.ctx.fillStyle = gradient;
                    this.ctx.shadowBlur = 20;
                    this.ctx.shadowColor = 'rgba(102, 126, 234, 0.6)';
                } else {
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                }
                
                this.ctx.fillRect(x, y, width, height);
                
                // Button border
                this.ctx.strokeStyle = highlighted ? '#00ffff' : 'rgba(255, 255, 255, 0.3)';
                this.ctx.lineWidth = 3;
                this.ctx.strokeRect(x, y, width, height);
                
                // Button text
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = 'bold ' + Math.floor(height * 0.35) + 'px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(text, x + width / 2, y + height / 2);
                
                this.ctx.restore();
                
                return { x: x, y: y, width: width, height: height };
            }

            drawSlider(x, y, width, height, value, max, label) {
                this.ctx.save();
                
                // Label
                this.ctx.fillStyle = '#aaa';
                this.ctx.font = 'bold ' + Math.floor(height * 0.8) + 'px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(label, x, y + height / 2);
                
                const labelWidth = this.ctx.measureText(label).width;
                const sliderX = x + labelWidth + 20;
                const sliderWidth = width - labelWidth - 80;
                
                // Slider track
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                this.ctx.fillRect(sliderX, y + height / 2 - 3, sliderWidth, 6);
                
                // Slider fill
                const fillWidth = (value / max) * sliderWidth;
                const gradient = this.ctx.createLinearGradient(sliderX, y, sliderX + fillWidth, y);
                gradient.addColorStop(0, '#00ffff');
                gradient.addColorStop(1, '#667eea');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(sliderX, y + height / 2 - 3, fillWidth, 6);
                
                // Slider thumb
                const thumbX = sliderX + fillWidth;
                this.ctx.fillStyle = '#00ffff';
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = 'rgba(0, 255, 255, 0.5)';
                this.ctx.beginPath();
                this.ctx.arc(thumbX, y + height / 2, 9, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Value display
                this.ctx.shadowBlur = 0;
                this.ctx.fillStyle = '#00ffff';
                this.ctx.font = 'bold ' + Math.floor(height * 0.7) + 'px Arial';
                this.ctx.textAlign = 'right';
                this.ctx.fillText(Math.round(value) + (label.includes('Volume') ? '%' : ''), 
                                 x + width, y + height / 2);
                
                this.ctx.restore();
                
                return { x: sliderX, y: y + height / 2 - 10, width: sliderWidth, height: 20 };
            }

            isPointInRect(px, py, rect) {
                return px >= rect.x && px <= rect.x + rect.width &&
                       py >= rect.y && py <= rect.y + rect.height;
            }
        }

        // ==================== GAME ENGINE ====================
        class RhythmRunner {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.ui = new UIRenderer(this.ctx, canvas);
                
                this.resizeCanvas();
                window.addEventListener('resize', () => {
                    this.resizeCanvas();
                    // Update mobile controls visibility when screen size changes
                    this.updateMobileControlsVisibility();
                });
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => this.resizeCanvas(), 100);
                });
                window.addEventListener('deviceorientationchange', () => {
                    setTimeout(() => this.resizeCanvas(), 100);
                });
                
                this.difficulty = 'easy';
                this.difficultyConfig = DIFFICULTY_CONFIGS.easy;
                
                // Initialize player and apply difficulty settings
                this.player = {
                    x: 100,
                    y: 350,
                    width: 30,
                    height: 30,
                    speed: 6,
                    health: 100,
                    maxHealth: 100,
                    isDashing: false,
                    dashCooldown: 0,
                    dashDuration: 0,
                    dashSpeed: 18,
                    dashMaxCooldown: 2000,
                    dashMaxDuration: 200,
                    regenAmount: 3,
                    regenInterval: 0
                };
                this.setDifficulty(this.difficulty);
                
                this.obstacles = [];
                this.obstacleTimestamps = [];
                this.score = 0;
                this.dodgedCount = 0;
                this.gameTime = 0;
                this.isRunning = false;
                this.isPaused = false;
                this.gameStartTime = 0;
                this.totalPausedTime = 0;
                this.pauseStartTime = 0;
                this.finalSurvivalTime = 0;
                this.healthRegenTimer = 0;

                this.audio = null;
                this.audioStartTime = 0;
                this.audioDuration = 0;
                this.volume = 70;
                
                this.currentScreen = 'menu';
                this.keys = {};
                this.mousePos = { x: 0, y: 0 };
                this.interactiveElements = {};
                this.isSliderDragging = false;
                this.pendingAudio = null;
                this.pendingObstacles = null;
                
                this.setupInput();
                this.setupMobileControls();
            }

            resizeCanvas() {
                // Get the actual viewport dimensions
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                const dpr = window.devicePixelRatio || 1;
                
                // Reset any existing transformations
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                
                // Set canvas internal resolution for device pixel ratio
                this.canvas.width = viewportWidth * dpr;
                this.canvas.height = viewportHeight * dpr;
                
                // Scale context to maintain coordinate consistency
                this.ctx.scale(dpr, dpr);
                
                // Don't set explicit style dimensions - let CSS handle the display
                // This prevents screen cutoff issues
                
                // Store logical dimensions (not affected by DPR)
                this.width = viewportWidth;
                this.height = viewportHeight;
                
                console.log(`Canvas resized: ${viewportWidth}x${viewportHeight} (DPR: ${dpr})`);
            }

            setDifficulty(difficulty) {
                this.difficulty = difficulty;
                this.difficultyConfig = DIFFICULTY_CONFIGS[difficulty];
                this.player.speed = this.difficultyConfig.playerSpeed;
                
                if (difficulty === 'easy') {
                    this.player.regenInterval = 3000;
                } else if (difficulty === 'medium') {
                    this.player.regenInterval = 7000;
                } else {
                    this.player.regenInterval = 0;
                }
            }

            setupInput() {
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'Tab') {
                        e.preventDefault();
                        return;
                    }
                    
                    this.keys[e.key] = true;
                    
                    if (e.key === ' ' || e.key === 'Escape') {
                        e.preventDefault();
                        if (this.currentScreen === 'game') {
                            this.togglePause();
                        }
                    }
                    
                    // DASH activation
                    if ((e.key === 'Shift' || e.shiftKey) && 
                        this.currentScreen === 'game' && !this.isPaused) {
                        e.preventDefault();
                        this.activateDash();
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    if (e.key === 'Tab') {
                        return;
                    }
                    this.keys[e.key] = false;
                });

                document.addEventListener('visibilitychange', () => {
                    if (document.hidden && this.currentScreen === 'game' && !this.isPaused) {
                        this.togglePause();
                    }
                });

                // Mouse/Touch for UI interactions
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mousePos.x = e.clientX - rect.left;
                    this.mousePos.y = e.clientY - rect.top;
                    
                    if (this.isSliderDragging) {
                        this.handleSliderDrag(this.mousePos.x, this.mousePos.y);
                    }
                });

                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    this.handleClick(x, y);
                });

                this.canvas.addEventListener('mousedown', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    if (this.interactiveElements.volumeSlider && this.ui.isPointInRect(x, y, this.interactiveElements.volumeSlider)) {
                        this.isSliderDragging = 'volume';
                        this.handleSliderDrag(x, y);
                    } else if (this.interactiveElements.songSlider && this.ui.isPointInRect(x, y, this.interactiveElements.songSlider)) {
                        this.isSliderDragging = 'song';
                        this.handleSliderDrag(x, y);
                    }
                });

                this.canvas.addEventListener('mouseup', () => {
                    this.isSliderDragging = false;
                });

                this.canvas.addEventListener('mouseleave', () => {
                    this.isSliderDragging = false;
                });

                // Mobile Canvas Touch Events (for all UI interactions)
                this.canvas.addEventListener('touchstart', (e) => {
                    console.log('Canvas touchstart detected');
                    if (e.changedTouches.length > 0) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const rect = this.canvas.getBoundingClientRect();
                        const touch = e.changedTouches[0];
                        
                        // Calculate coordinates relative to canvas content (not CSS box)
                        const scaleX = this.width / rect.width;
                        const scaleY = this.height / rect.height;
                        const x = (touch.clientX - rect.left) * scaleX;
                        const y = (touch.clientY - rect.top) * scaleY;
                        
                        console.log(`Touch: client=(${touch.clientX}, ${touch.clientY})`);
                        console.log(`Rect: left=${rect.left}, top=${rect.top}, w=${rect.width}, h=${rect.height}`);
                        console.log(`Canvas: w=${this.width}, h=${this.height}`);
                        console.log(`Coords: x=${x}, y=${y}, scale=(${scaleX}, ${scaleY})`);
                        
                        this.handleClick(x, y);
                    }
                }, { passive: false });

                this.canvas.addEventListener('touchend', (e) => {
                    console.log('Canvas touchend detected');
                    if (e.changedTouches.length > 0) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const rect = this.canvas.getBoundingClientRect();
                        const touch = e.changedTouches[0];
                        
                        // Calculate coordinates relative to canvas content (not CSS box)
                        const scaleX = this.width / rect.width;
                        const scaleY = this.height / rect.height;
                        const x = (touch.clientX - rect.left) * scaleX;
                        const y = (touch.clientY - rect.top) * scaleY;
                        
                        console.log(`Touchend coords: x=${x}, y=${y}`);
                        this.handleClick(x, y);
                    }
                }, { passive: false });

                this.canvas.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, { passive: false });

                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, { passive: false });
            }

            setupMobileControls() {
                const upBtn = document.getElementById('upBtn');
                const downBtn = document.getElementById('downBtn');
                const leftBtn = document.getElementById('leftBtn');
                const rightBtn = document.getElementById('rightBtn');
                const dashBtn = document.getElementById('dashBtn');
                const pauseBtn = document.getElementById('pauseBtn');
                
                // Simple and reliable touch handling
                const setupButton = (button, key) => {
                    const startPress = () => {
                        this.keys[key] = true;
                        button.classList.add('pressed');
                    };
                    
                    const endPress = () => {
                        this.keys[key] = false;
                        button.classList.remove('pressed');
                    };
                    
                    // Touch events
                    button.addEventListener('touchstart', startPress, { passive: false });
                    button.addEventListener('touchend', endPress, { passive: false });
                    button.addEventListener('touchcancel', endPress, { passive: false });
                    
                    // Mouse events for testing
                    button.addEventListener('mousedown', startPress);
                    button.addEventListener('mouseup', endPress);
                    button.addEventListener('mouseleave', endPress);
                };
                
                // Setup movement buttons
                setupButton(upBtn, 'ArrowUp');
                setupButton(downBtn, 'ArrowDown');
                setupButton(leftBtn, 'ArrowLeft');
                setupButton(rightBtn, 'ArrowRight');
                
                // Dash button
                const dashStart = () => {
                    this.activateDash();
                    dashBtn.classList.add('pressed');
                    setTimeout(() => dashBtn.classList.remove('pressed'), 200);
                };
                
                dashBtn.addEventListener('touchstart', dashStart, { passive: false });
                dashBtn.addEventListener('touchend', () => dashBtn.classList.remove('pressed'), { passive: false });
                dashBtn.addEventListener('touchcancel', () => dashBtn.classList.remove('pressed'), { passive: false });
                dashBtn.addEventListener('mousedown', dashStart);
                
                // Pause button
                const pauseStart = () => {
                    if (this.currentScreen === 'game') {
                        this.togglePause();
                        pauseBtn.classList.add('pressed');
                        setTimeout(() => pauseBtn.classList.remove('pressed'), 200);
                    }
                };
                
                pauseBtn.addEventListener('touchstart', pauseStart, { passive: false });
                pauseBtn.addEventListener('touchend', () => pauseBtn.classList.remove('pressed'), { passive: false });
                pauseBtn.addEventListener('touchcancel', () => pauseBtn.classList.remove('pressed'), { passive: false });
                pauseBtn.addEventListener('click', pauseStart);
                
                // Global touch handlers to prevent stuck states
                document.addEventListener('touchend', () => {
                    // Release all keys when any touch ends
                    this.keys['ArrowUp'] = false;
                    this.keys['ArrowDown'] = false;
                    this.keys['ArrowLeft'] = false;
                    this.keys['ArrowRight'] = false;
                    
                    [upBtn, downBtn, leftBtn, rightBtn].forEach(btn => {
                        btn.classList.remove('pressed');
                    });
                }, { passive: true });
            }

            handleSliderDrag(x, y) {
                if (this.isSliderDragging === 'volume' && this.interactiveElements.volumeSlider) {
                    const percent = Math.max(0, Math.min(1, (x - this.interactiveElements.volumeSlider.x) / this.interactiveElements.volumeSlider.width));
                    this.volume = percent * 100;
                    if (this.audio) {
                        this.audio.volume = this.volume / 100;
                    }
                } else if (this.isSliderDragging === 'song' && this.interactiveElements.songSlider && this.audioDuration > 0) {
                    const percent = Math.max(0, Math.min(1, (x - this.interactiveElements.songSlider.x) / this.interactiveElements.songSlider.width));
                    const seekTime = percent * this.audioDuration;
                    if (this.audio) {
                        this.audio.currentTime = seekTime;
                        this.audioStartTime = Date.now() - (seekTime * 1000) - this.totalPausedTime;
                    }
                }
            }

            handleClick(x, y) {
                console.log(`handleClick called with coordinates: x=${x}, y=${y}`);
                const el = this.interactiveElements;
                console.log(`Available interactive elements:`, Object.keys(el));
                console.log(`Canvas size: ${this.width}x${this.height}`);
                
                for (let key in el) {
                    if (el[key] && el[key].type === 'button') {
                        const rect = el[key];
                        const inRect = this.ui.isPointInRect(x, y, rect);
                        console.log(`Button ${key}: rect=(${rect.x}, ${rect.y}, ${rect.width}x${rect.height}), inRect=${inRect}`);
                        if (inRect) {
                            console.log(`Executing callback for ${key}`);
                            el[key].callback();
                            return;
                        }
                    }
                }
                console.log('No button clicked');
            }

            activateDash() {
                if (this.player.dashCooldown <= 0 && !this.player.isDashing) {
                    this.player.isDashing = true;
                    this.player.dashDuration = this.player.dashMaxDuration;
                    this.player.dashCooldown = this.player.dashMaxCooldown;
                }
            }

            loadObstacles(timestamps) {
                const filtered = [];
                const rate = this.difficultyConfig.spawnRateMultiplier;
                
                for (let i = 0; i < timestamps.length; i++) {
                    if (Math.random() < rate || rate >= 1.0) {
                        filtered.push(timestamps[i]);
                    } else if (i % Math.ceil(1 / rate) === 0) {
                        filtered.push(timestamps[i]);
                    }
                }
                
                this.obstacleTimestamps = filtered.sort((a, b) => a.time - b.time);
            }

            start(audio) {
                this.audio = audio;
                this.audioDuration = audio.duration;
                this.audio.volume = this.volume / 100;
                
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.audioAnalyser = this.audioContext.createAnalyser();
                    this.audioAnalyser.fftSize = 256;
                    this.audioAnalyser.smoothingTimeConstant = 0.8;
                    
                    const source = this.audioContext.createMediaElementSource(audio);
                    source.connect(this.audioAnalyser);
                    this.audioAnalyser.connect(this.audioContext.destination);
                } catch (e) {
                    console.warn('Audio analyser setup failed:', e);
                    this.audioAnalyser = null;
                }
                
                this.isRunning = true;
                this.currentScreen = 'game';
                this.gameStartTime = Date.now();
                this.audioStartTime = Date.now();
                this.totalPausedTime = 0;
                this.pauseStartTime = 0;
                this.healthRegenTimer = 0;
                this.audio.play();
                this.updateMobileControlsVisibility();
                this.gameLoop();
            }

            startPendingGame() {
                if (this.pendingAudio && this.pendingObstacles) {
                    this.loadObstacles([...this.pendingObstacles]);
                    this.start(this.pendingAudio);
                    this.pendingAudio = null;
                    this.pendingObstacles = null;
                    this.statusMessage = '';
                    
                    // Force landscape orientation for gameplay
                    this.requestLandscapeOrientation();
                }
            }

            formatTime(seconds) {
                if (!seconds || isNaN(seconds) || seconds < 0) {
                    return '0:00';
                }
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return mins + ':' + (secs < 10 ? '0' : '') + secs;
            }

            togglePause() {
                if (!this.isRunning) return;
                
                this.isPaused = !this.isPaused;
                this.currentScreen = this.isPaused ? 'pause' : 'game';
                this.updateMobileControlsVisibility();
                
                if (this.isPaused) {
                    this.pauseStartTime = Date.now();
                    this.audio.pause();
                } else {
                    if (this.pauseStartTime > 0) {
                        this.totalPausedTime += Date.now() - this.pauseStartTime;
                        this.pauseStartTime = 0;
                    }
                    this.audio.play();
                }
            }

            spawnObstacle(timestamp) {
                const config = this.difficultyConfig;
                const obstacle = {
                    type: timestamp.type,
                    x: this.width,
                    y: 0,
                    width: 0,
                    height: 0,
                    speed: 0,
                    damage: Math.round(10 * config.damageMultiplier),
                    isActive: false,
                    activateTime: 0,
                    warningDuration: config.warningDuration
                };

                switch (timestamp.type) {
                    case 'laser':
                        obstacle.width = 8;
                        obstacle.height = this.height;
                        obstacle.x = 0;
                        obstacle.y = 0;
                        obstacle.isVertical = Math.random() > 0.4;
                        
                        if (!obstacle.isVertical) {
                            obstacle.width = this.width;
                            obstacle.height = 8;
                            obstacle.y = Math.random() * (this.height - 150) + 75;
                            obstacle.x = 0;
                        }
                        obstacle.damage = Math.round(15 * config.damageMultiplier);
                        break;
                    
                    case 'square':
                        obstacle.width = 40;
                        obstacle.height = 40;
                        const minY = 60;
                        const maxY = this.height - obstacle.height - 60;
                        obstacle.y = minY + Math.random() * (maxY - minY);
                        obstacle.speed = (4 + Math.random() * 2) * config.obstacleSpeedMultiplier;
                        break;
                    
                    case 'triangle':
                        obstacle.width = 50;
                        obstacle.height = 50;
                        const triMinY = 50;
                        const triMaxY = this.height - obstacle.height - 50;
                        obstacle.y = triMinY + Math.random() * (triMaxY - triMinY);
                        obstacle.speed = 3.5 * config.obstacleSpeedMultiplier;
                        obstacle.curveDirection = Math.random() > 0.5 ? 1 : -1;
                        obstacle.curveAmount = 0;
                        obstacle.curveSpeed = 0.04 + Math.random() * 0.03;
                        break;
                }

                obstacle.activateTime = this.gameTime + obstacle.warningDuration;
                this.obstacles.push(obstacle);
            }

            update() {
                if (!this.isRunning) return;

                if (this.isPaused) return;

                this.gameTime = Date.now() - this.audioStartTime - this.totalPausedTime;
                
                if (this.audio.ended) {
                    this.victory();
                    return;
                }
                
                while (this.obstacleTimestamps.length > 0 && 
                       this.obstacleTimestamps[0].time <= this.gameTime) {
                    this.spawnObstacle(this.obstacleTimestamps.shift());
                }
                
                if (this.player.isDashing) {
                    this.player.dashDuration -= 16;
                    if (this.player.dashDuration <= 0) {
                        this.player.isDashing = false;
                        this.player.dashDuration = 0;
                    }
                }
                
                if (this.player.dashCooldown > 0) {
                    this.player.dashCooldown = Math.max(0, this.player.dashCooldown - 16);
                }
                
                if (this.player.regenInterval > 0 && this.player.health < this.player.maxHealth) {
                    this.healthRegenTimer += 16;
                    if (this.healthRegenTimer >= this.player.regenInterval) {
                        this.player.health = Math.min(this.player.maxHealth, 
                                                     this.player.health + this.player.regenAmount);
                        this.healthRegenTimer = 0;
                    }
                }
                
                const currentSpeed = this.player.isDashing ? this.player.dashSpeed : this.player.speed;
                
                if (this.keys['ArrowUp'] || this.keys['w'] || this.keys['W']) {
                    this.player.y = Math.max(0, this.player.y - currentSpeed);
                }
                if (this.keys['ArrowDown'] || this.keys['s'] || this.keys['S']) {
                    this.player.y = Math.min(this.height - this.player.height, 
                                            this.player.y + currentSpeed);
                }
                if (this.keys['ArrowLeft'] || this.keys['a'] || this.keys['A']) {
                    this.player.x = Math.max(0, this.player.x - currentSpeed);
                }
                if (this.keys['ArrowRight'] || this.keys['d'] || this.keys['D']) {
                    this.player.x = Math.min(this.width - this.player.width, 
                                            this.player.x + currentSpeed);
                }
                
                for (let i = this.obstacles.length - 1; i >= 0; i--) {
                    const obs = this.obstacles[i];
                    
                    if (!obs.isActive && this.gameTime >= obs.activateTime) {
                        obs.isActive = true;
                    }
                    
                    if (obs.type === 'square') {
                        obs.x -= obs.speed;
                    } else if (obs.type === 'triangle') {
                        obs.x -= obs.speed;
                        obs.curveAmount += obs.curveSpeed;
                        obs.y += Math.sin(obs.curveAmount) * obs.curveDirection * 3;
                        obs.y = Math.max(0, Math.min(this.height - obs.height, obs.y));
                    }
                    
                    if (!this.player.isDashing && this.checkCollision(this.player, obs)) {
                        const damageMultiplier = obs.isActive ? 1.0 : 0.25;
                        this.player.health = Math.max(0, this.player.health - (obs.damage * damageMultiplier));
                        this.obstacles.splice(i, 1);
                        
                        if (this.player.health <= 0) {
                            this.gameOver();
                        }
                        continue;
                    }
                    
                    if (obs.isActive && this.player.isDashing && this.checkCollision(this.player, obs)) {
                        this.obstacles.splice(i, 1);
                        this.score += 25;
                        this.dodgedCount++;
                        continue;
                    }
                    
                    let shouldRemove = false;
                    
                    if (obs.type === 'square' || obs.type === 'triangle') {
                        if (obs.x < -100) {
                            shouldRemove = true;
                        }
                    } else if (obs.type === 'laser') {
                        const laserActiveTime = this.gameTime - obs.activateTime;
                        if (laserActiveTime > 3000) {
                            shouldRemove = true;
                        }
                    }
                    
                    if (shouldRemove) {
                        this.obstacles.splice(i, 1);
                        this.score += 10;
                        this.dodgedCount++;
                    }
                }
            }

            checkCollision(player, obstacle) {
                return player.x < obstacle.x + obstacle.width &&
                       player.x + player.width > obstacle.x &&
                       player.y < obstacle.y + obstacle.height &&
                       player.y + player.height > obstacle.y;
            }

            draw() {
                this.ctx.fillStyle = '#0a0a1a';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                this.interactiveElements = {};
                
                // Show/hide mobile controls based on game state
                this.updateMobileControlsVisibility();
                
                if (this.currentScreen === 'menu') {
                    this.drawMenuScreen();
                } else if (this.currentScreen === 'game') {
                    this.drawGameScreen();
                } else if (this.currentScreen === 'pause') {
                    this.drawPauseScreen();
                } else if (this.currentScreen === 'gameover') {
                    this.drawGameOverScreen();
                } else if (this.currentScreen === 'victory') {
                    this.drawVictoryScreen();
                }
            }

            updateMobileControlsVisibility() {
                const mobileControls = document.querySelector('.mobile-controls');
                const portraitNotice = document.querySelector('.portrait-notice');
                if (!mobileControls) return;
                
                // Only show mobile controls during active gameplay (not paused)
                const shouldShowControls = this.currentScreen === 'game' && !this.isPaused;
                
                if (shouldShowControls) {
                    mobileControls.style.display = 'block';
                    
                    // Add gameplay class to body for CSS targeting
                    document.body.classList.add('gameplay');
                    
                    // Show/hide portrait notice based on orientation during gameplay
                    if (portraitNotice) {
                        const isPortrait = window.innerHeight > window.innerWidth;
                        if (isPortrait) {
                            portraitNotice.style.display = 'block';
                        } else {
                            portraitNotice.style.display = 'none';
                        }
                    }
                } else {
                    mobileControls.style.display = 'none';
                    
                    // Remove gameplay class when not in game
                    document.body.classList.remove('gameplay');
                    
                    if (portraitNotice) {
                        portraitNotice.style.display = 'none';
                    }
                }
            }

            // Screen orientation control for mobile devices
            async requestLandscapeOrientation() {
                // Force landscape orientation during gameplay
                if (screen.orientation && screen.orientation.lock) {
                    try {
                        await screen.orientation.lock('landscape-primary');
                    } catch (error) {
                        console.log('Screen orientation lock not supported:', error);
                        // Fallback to CSS orientation hints
                        document.body.style.transform = 'rotate(0deg)';
                    }
                }
            }

            async unlockOrientation() {
                // Unlock to allow portrait orientation in menus
                if (screen.orientation && screen.orientation.unlock) {
                    try {
                        await screen.orientation.unlock();
                    } catch (error) {
                        console.log('Screen orientation unlock not supported:', error);
                        // Fallback - remove CSS transforms
                        document.body.style.transform = 'rotate(0deg)';
                    }
                }
            }

            drawMenuScreen() {
                // Calculate optimal content area for different screen sizes
                const ThisAspectRatio = this.width / this.height;
                let contentWidth, contentX;
                
                if (ThisAspectRatio > 2.5) {
                    // Ultra-wide screens (21:9, 32:9, etc.) - constrain content width
                    contentWidth = Math.min(1200, this.height * 1.8);
                    contentX = (this.width - contentWidth) / 2;
                } else if (ThisAspectRatio > 1.8) {
                    // Wide screens (16:9, 21:9) - moderate constraint
                    contentWidth = Math.min(1000, this.height * 1.4);
                    contentX = (this.width - contentWidth) / 2;
                } else {
                    // Standard screens - use full width
                    contentWidth = this.width;
                    contentX = 0;
                }
                
                const centerX = contentX + contentWidth / 2;
                const centerY = this.height / 2;
                
                // Title - responsive sizing with content constraint
                this.ctx.fillStyle = '#ffffff';
                const titleSize = Math.max(24, Math.min(48, contentWidth * 0.06));
                this.ctx.font = 'bold ' + titleSize + 'px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.shadowBlur = 20;
                this.ctx.shadowColor = 'rgba(0, 255, 255, 0.5)';
                this.ctx.fillText('üéµ RHYTHM OBSTACLE RUNNER', centerX, this.height * 0.15);
                
                this.ctx.shadowBlur = 0;
                const subtitleSize = Math.max(14, Math.min(20, contentWidth * 0.03));
                this.ctx.font = subtitleSize + 'px Arial';
                this.ctx.fillStyle = '#aaa';
                this.ctx.fillText('Load a song and dodge AI-generated obstacles!', 
                                 centerX, this.height * 0.22);
                
                // Difficulty selection - responsive with content constraint
                const diffLabel = 'Select Difficulty:';
                this.ctx.fillStyle = '#00ffff';
                this.ctx.font = 'bold ' + Math.max(18, contentWidth * 0.04) + 'px Arial';
                this.ctx.fillText(diffLabel, centerX, this.height * 0.3);
                
                const difficulties = ['easy', 'medium', 'hard', 'epic'];
                const diffNames = ['Easy', 'Medium', 'Hard', 'Epic Gamer'];
                
                // Detect landscape phone orientation for better sizing
                const isLandscapePhone = this.width > this.height && this.width < 900;
                const aspectRatio = this.width / this.height;
                
                // Adaptive sizing based on screen type
                let maxButtonWidth, buttonSpacing, minButtonWidth, buttonHeight;
                
                if (isLandscapePhone) {
                    // Landscape phone: use smaller proportions to prevent clipping
                    maxButtonWidth = Math.min(150, this.width * 0.20); // Max 20% of width, capped at 150px
                    minButtonWidth = 70; // Smaller minimum for landscape
                    buttonSpacing = Math.max(10, this.width * 0.015); // Minimal spacing for landscape
                    buttonHeight = Math.max(35, this.height * 0.05); // Smaller height for landscape
                } else {
                    // Portrait or desktop: use larger proportions
                    maxButtonWidth = Math.min(200, this.width * 0.22); // 22% of width, capped at 200px
                    minButtonWidth = 100; // Larger minimum for portrait/desktop
                    buttonSpacing = Math.max(15, this.width * 0.02); // Better spacing for portrait
                    buttonHeight = Math.max(45, this.height * 0.06); // Standard height
                }
                
                const totalSpacing = (difficulties.length - 1) * buttonSpacing;
                const totalButtonsWidth = difficulties.length * maxButtonWidth;
                
                // Use 93% of screen width with proper margins
                const availableWidth = this.width * 0.93;
                const minMargin = isLandscapePhone ? 10 : 20; // Smaller margins for landscape
                
                // Scale down buttons if they don't fit
                let actualButtonWidth, startX, y;
                
                if (totalButtonsWidth + totalSpacing > availableWidth - (minMargin * 2)) {
                    // Calculate scaling to fit within available space
                    const maxAvailableForButtons = availableWidth - (minMargin * 2) - totalSpacing;
                    actualButtonWidth = Math.max(minButtonWidth, maxAvailableForButtons / difficulties.length);
                } else {
                    // Use calculated size
                    actualButtonWidth = maxButtonWidth;
                }
                
                // Center the buttons horizontally with proper margins
                const totalWidth = difficulties.length * actualButtonWidth + totalSpacing;
                startX = Math.max(minMargin, centerX - totalWidth / 2);
                y = this.height * 0.35;
                y = this.height * 0.35;
                
                for (let i = 0; i < difficulties.length; i++) {
                    const x = startX + (i * (actualButtonWidth + buttonSpacing));
                    const highlighted = this.difficulty === difficulties[i];
                    
                    const btn = this.ui.drawButton(x, y, actualButtonWidth, buttonHeight, 
                                                   diffNames[i], highlighted);
                    this.interactiveElements['diff_' + i] = {
                        ...btn,
                        type: 'button',
                        callback: () => this.setDifficulty(difficulties[i])
                    };
                }
                
                // Choose file button
                const fileBtnWidth = Math.min(320, contentWidth * 0.7);
                const fileBtn = this.ui.drawButton(centerX - fileBtnWidth/2, this.height * 0.48, fileBtnWidth, 60, 
                                                   'üéµ Choose Music File', false);
                this.interactiveElements.fileBtn = {
                    ...fileBtn,
                    type: 'button',
                    callback: () => this.openFileDialog()
                };
                
                // Start Run button
                if (this.pendingAudio && this.pendingObstacles) {
                    const startBtnWidth = Math.min(280, contentWidth * 0.6);
                    const startBtn = this.ui.drawButton(centerX - startBtnWidth/2, this.height * 0.58, startBtnWidth, 60, 
                                                       '‚ñ∂Ô∏è Start Run!', false);
                    this.interactiveElements.startBtn = {
                        ...startBtn,
                        type: 'button',
                        callback: () => this.startPendingGame()
                    };
                }
                
                // Status message
                if (this.statusMessage) {
                    this.ctx.fillStyle = this.statusColor || '#00ffff';
                    this.ctx.font = Math.max(16, contentWidth * 0.03) + 'px Arial';
                    this.ctx.fillText(this.statusMessage, centerX, this.height * 0.72);
                    
                    if (this.loadingProgress !== undefined) {
                        const barWidth = Math.min(400, contentWidth * 0.8);
                        const barHeight = 8;
                        const barX = centerX - barWidth / 2;
                        const barY = this.height * 0.68;
                        
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                        this.ctx.fillRect(barX, barY, barWidth, barHeight);
                        
                        const gradient = this.ctx.createLinearGradient(barX, barY, 
                                                                      barX + barWidth * this.loadingProgress, barY);
                        gradient.addColorStop(0, '#00ffff');
                        gradient.addColorStop(1, '#667eea');
                        this.ctx.fillStyle = gradient;
                        this.ctx.fillRect(barX, barY, barWidth * this.loadingProgress, barHeight);
                    }
                }
                
                // Controls
                this.ctx.fillStyle = '#666';
                this.ctx.font = Math.max(12, contentWidth * 0.025) + 'px Arial';
                this.ctx.fillText('Arrow Keys/WASD: Move | Shift: Dash | Space: Pause', 
                                 centerX, this.height * 0.9);
            }

            drawGameScreen() {
                this.drawDynamicBackground();
                this.drawGrid();
                this.drawObstacles();
                this.drawPlayer();
                this.drawGameHUD();
            }

            drawGrid() {
                this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.08)';
                this.ctx.lineWidth = 1;
                
                const gridSize = 50;
                for (let x = 0; x < this.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.height);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y < this.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.width, y);
                    this.ctx.stroke();
                }
            }

            drawObstacles() {
                this.obstacles.forEach(obs => {
                    const isWarning = !obs.isActive;
                    const warningProgress = 1 - ((obs.activateTime - this.gameTime) / obs.warningDuration);
                    const alpha = isWarning ? (0.2 + warningProgress * 0.3) : 1.0;
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = alpha;
                    
                    if (obs.type === 'laser') {
                        const gradient = isWarning ? 
                            this.ctx.createLinearGradient(obs.x, obs.y, obs.x + obs.width, obs.y + obs.height) :
                            this.ctx.createLinearGradient(obs.x, obs.y, obs.x + obs.width, obs.y + obs.height);
                        
                        if (isWarning) {
                            gradient.addColorStop(0, '#ffff00');
                            gradient.addColorStop(1, '#ffaa00');
                        } else {
                            gradient.addColorStop(0, '#ff0000');
                            gradient.addColorStop(0.5, '#ff6600');
                            gradient.addColorStop(1, '#ff0000');
                            this.ctx.shadowBlur = 25;
                            this.ctx.shadowColor = '#ff0000';
                        }
                        
                        this.ctx.fillStyle = gradient;
                        this.ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                    } 
                    else if (obs.type === 'square') {
                        this.ctx.fillStyle = isWarning ? '#666666' : '#00ffff';
                        this.ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                        
                        if (!isWarning) {
                            this.ctx.shadowBlur = 15;
                            this.ctx.shadowColor = '#00ffff';
                            this.ctx.strokeStyle = '#ffffff';
                            this.ctx.lineWidth = 3;
                            this.ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);
                        }
                    } 
                    else if (obs.type === 'triangle') {
                        this.ctx.fillStyle = isWarning ? '#666666' : '#ff00ff';
                        this.ctx.beginPath();
                        this.ctx.moveTo(obs.x + obs.width / 2, obs.y);
                        this.ctx.lineTo(obs.x, obs.y + obs.height);
                        this.ctx.lineTo(obs.x + obs.width, obs.y + obs.height);
                        this.ctx.closePath();
                        this.ctx.fill();
                        
                        if (!isWarning) {
                            this.ctx.shadowBlur = 15;
                            this.ctx.shadowColor = '#ff00ff';
                            this.ctx.strokeStyle = '#ffffff';
                            this.ctx.lineWidth = 3;
                            this.ctx.stroke();
                        }
                    }
                    
                    this.ctx.restore();
                });
            }

            drawDynamicBackground() {
                if (!this.audio) return;
                
                const analyser = this.audioAnalyser;
                if (!analyser) return;
                
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                analyser.getByteFrequencyData(dataArray);
                
                let sum = 0;
                for (let i = 0; i < Math.min(32, bufferLength); i++) {
                    sum += dataArray[i];
                }
                const averageVolume = sum / Math.min(32, bufferLength);
                const intensity = averageVolume / 255;
                
                const hue1 = (Date.now() * 0.02 + intensity * 180) % 360;
                const hue2 = (hue1 + 60) % 360;
                const brightness = 0.1 + (intensity * 0.3);
                
                const gradient = this.ctx.createLinearGradient(0, 0, this.width, this.height);
                gradient.addColorStop(0, `hsla(${hue1}, 70%, ${brightness * 100}%, 0.3)`);
                gradient.addColorStop(0.5, `hsla(${hue2}, 80%, ${brightness * 50}%, 0.2)`);
                gradient.addColorStop(1, `hsla(${(hue1 + 180) % 360}, 60%, ${brightness * 30}%, 0.3)`);
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                const barCount = 8;
                const barWidth = this.width / barCount;
                for (let i = 0; i < barCount; i++) {
                    const freqIndex = Math.floor((i / barCount) * bufferLength);
                    const barHeight = (dataArray[freqIndex] / 255) * this.height * 0.3;
                    
                    const hue = (hue1 + (i / barCount) * 120) % 360;
                    this.ctx.fillStyle = `hsla(${hue}, 60%, ${20 + intensity * 30}%, 0.1)`;
                    this.ctx.fillRect(i * barWidth, this.height - barHeight, barWidth - 2, barHeight);
                }
                
                const bassSum = dataArray.slice(0, 4).reduce((a, b) => a + b, 0) / (4 * 255);
                if (bassSum > 0.1) {
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${bassSum * 0.05})`;
                    this.ctx.fillRect(0, 0, this.width, this.height);
                }
            }

            drawPlayer() {
                this.ctx.save();
                
                if (this.player.isDashing) {
                    this.ctx.fillStyle = '#ffff00';
                    this.ctx.shadowBlur = 40;
                    this.ctx.shadowColor = '#ffff00';
                    
                    for (let i = 1; i <= 3; i++) {
                        this.ctx.globalAlpha = 0.3 / i;
                        this.ctx.fillRect(this.player.x - (i * 10), this.player.y, 
                                         this.player.width, this.player.height);
                    }
                    this.ctx.globalAlpha = 1.0;
                } else {
                    this.ctx.fillStyle = '#00ff00';
                    this.ctx.shadowBlur = 20;
                    this.ctx.shadowColor = '#00ff00';
                }
                
                this.ctx.fillRect(this.player.x, this.player.y, 
                                 this.player.width, this.player.height);
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 3;
                this.ctx.strokeRect(this.player.x, this.player.y, 
                                   this.player.width, this.player.height);
                this.ctx.restore();
            }

            drawGameHUD() {
                const padding = 20;
                const hudAlpha = 0.9;
                
                this.ctx.save();
                this.ctx.globalAlpha = hudAlpha;
                
                // Song progress bar (top-center)
                if (this.audio && this.audioDuration > 0) {
                    const songProgressBarWidth = Math.min(600, this.width * 0.6);
                    const songProgressBarHeight = 25;
                    const songProgressX = (this.width - songProgressBarWidth) / 2;
                    const songProgressY = padding;
                    
                    // Background
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                    this.ctx.fillRect(songProgressX - 5, songProgressY - 5, songProgressBarWidth + 10, songProgressBarHeight + 30);
                    
                    // Progress bar background
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    this.ctx.fillRect(songProgressX, songProgressY, songProgressBarWidth, songProgressBarHeight);
                    
                    // Progress fill
                    const currentTime = this.audio.currentTime || 0;
                    const progressPercent = currentTime / this.audioDuration;
                    const progressWidth = songProgressBarWidth * progressPercent;
                    
                    this.ctx.fillStyle = '#00ffff';
                    this.ctx.fillRect(songProgressX, songProgressY, progressWidth, songProgressBarHeight);
                    
                    // Border
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(songProgressX, songProgressY, songProgressBarWidth, songProgressBarHeight);
                    
                    // Time text
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = 'bold 14px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    const currentTimeText = this.formatTime(currentTime);
                    const totalTimeText = this.formatTime(this.audioDuration);
                    this.ctx.fillText(`${currentTimeText} / ${totalTimeText}`, 
                                     songProgressX + songProgressBarWidth / 2, 
                                     songProgressY + songProgressBarHeight + 15);
                }
                
                // Health bar (top-left)
                const healthBarWidth = Math.min(250, this.width * 0.3);
                const healthBarHeight = 30;
                
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                this.ctx.fillRect(padding - 5, padding - 5, healthBarWidth + 10, healthBarHeight + 10);
                
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                this.ctx.fillRect(padding, padding, healthBarWidth, healthBarHeight);
                
                const healthWidth = (this.player.health / this.player.maxHealth) * healthBarWidth;
                const gradient = this.ctx.createLinearGradient(padding, padding, padding + healthWidth, padding);
                
                if (this.player.health > 50) {
                    gradient.addColorStop(0, '#00ff00');
                    gradient.addColorStop(1, '#00cc00');
                } else if (this.player.health > 25) {
                    gradient.addColorStop(0, '#ffff00');
                    gradient.addColorStop(1, '#ff8800');
                } else {
                    gradient.addColorStop(0, '#ff0000');
                    gradient.addColorStop(1, '#cc0000');
                }
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(padding, padding, healthWidth, healthBarHeight);
                
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(padding, padding, healthBarWidth, healthBarHeight);
                
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(Math.round(this.player.health) + ' HP', 
                                 padding + healthBarWidth / 2, padding + healthBarHeight / 2);
                
                // Score and stats (top-right)
                const statsX = this.width - padding;
                const fontSize = Math.max(16, this.width * 0.025);
                this.ctx.font = 'bold ' + fontSize + 'px Arial';
                this.ctx.textAlign = 'right';
                this.ctx.textBaseline = 'top';
                
                this.ctx.fillStyle = '#00ffff';
                this.ctx.fillText('Score: ' + this.score, statsX, padding);
                this.ctx.fillText('Dodged: ' + this.dodgedCount, statsX, padding + fontSize + 5);
                this.ctx.fillText('Difficulty: ' + this.difficultyConfig.name, statsX, padding + (fontSize + 5) * 2);
                
                this.ctx.restore();
            }

            drawPauseScreen() {
                this.ctx.save();
                this.ctx.globalAlpha = 0.3;
                this.drawGrid();
                this.drawObstacles();
                this.drawPlayer();
                this.ctx.restore();
                
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                const centerX = this.width / 2;
                const centerY = this.height / 2;
                
                const panelWidth = Math.min(600, this.width * 0.8);
                const panelHeight = Math.min(500, this.height * 0.7);
                const panelX = centerX - panelWidth / 2;
                const panelY = centerY - panelHeight / 2;
                
                this.ctx.fillStyle = 'rgba(26, 26, 46, 0.95)';
                this.ctx.fillRect(panelX, panelY, panelWidth, panelHeight);
                this.ctx.strokeStyle = '#00ffff';
                this.ctx.lineWidth = 3;
                this.ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);
                
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = 'bold ' + Math.floor(panelHeight * 0.12) + 'px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText('‚è∏ PAUSED', centerX, panelY + panelHeight * 0.15);
                
                const sliderY = panelY + panelHeight * 0.35;
                this.interactiveElements.volumeSlider = this.ui.drawSlider(
                    panelX + 40, sliderY, panelWidth - 80, 30, 
                    this.volume, 100, 'Volume:'
                );
                
                const resumeBtn = this.ui.drawButton(centerX - 120, panelY + panelHeight * 0.5, 
                                                     240, 50, 'Resume', false);
                this.interactiveElements.resumeBtn = {
                    ...resumeBtn,
                    type: 'button',
                    callback: () => this.togglePause()
                };
                
                const menuBtn = this.ui.drawButton(centerX - 120, panelY + panelHeight * 0.64, 
                                                   240, 50, 'Return to Menu', false);
                this.interactiveElements.menuBtn = {
                    ...menuBtn,
                    type: 'button',
                    callback: () => this.returnToMenu()
                };
            }

            drawGameOverScreen() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                const centerX = this.width / 2;
                const centerY = this.height / 2;
                
                const panelWidth = Math.min(500, this.width * 0.8);
                const panelHeight = Math.min(450, this.height * 0.7);
                const panelX = centerX - panelWidth / 2;
                const panelY = centerY - panelHeight / 2;
                
                this.ctx.fillStyle = 'rgba(26, 26, 46, 0.95)';
                this.ctx.fillRect(panelX, panelY, panelWidth, panelHeight);
                this.ctx.strokeStyle = '#ff0000';
                this.ctx.lineWidth = 3;
                this.ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);
                
                this.ctx.fillStyle = '#ff0000';
                this.ctx.font = 'bold ' + Math.floor(panelHeight * 0.12) + 'px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText('üíÄ GAME OVER', centerX, panelY + panelHeight * 0.15);
                
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = Math.floor(panelHeight * 0.06) + 'px Arial';
                const statsY = panelY + panelHeight * 0.35;
                const lineHeight = panelHeight * 0.08;
                
                this.ctx.fillText('Final Score: ' + this.score, centerX, statsY);
                this.ctx.fillText('Obstacles Dodged: ' + this.dodgedCount, centerX, statsY + lineHeight);
                this.ctx.fillText('Survival Time: ' + this.formatTime(this.finalSurvivalTime), 
                                 centerX, statsY + lineHeight * 2);
                
                const tryBtn = this.ui.drawButton(centerX - 120, panelY + panelHeight * 0.68, 
                                                  240, 50, 'Try Again', false);
                this.interactiveElements.tryBtn = {
                    ...tryBtn,
                    type: 'button',
                    callback: () => this.restartGame()
                };
                
                const menuBtn = this.ui.drawButton(centerX - 120, panelY + panelHeight * 0.82, 
                                                   240, 50, 'Choose New Song', false);
                this.interactiveElements.menuBtn2 = {
                    ...menuBtn,
                    type: 'button',
                    callback: () => this.returnToMenu()
                };
            }

            drawVictoryScreen() {
                this.ctx.fillStyle = 'rgba(0, 50, 0, 0.85)';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                const centerX = this.width / 2;
                const centerY = this.height / 2;
                
                const panelWidth = Math.min(500, this.width * 0.8);
                const panelHeight = Math.min(500, this.height * 0.7);
                const panelX = centerX - panelWidth / 2;
                const panelY = centerY - panelHeight / 2;
                
                this.ctx.fillStyle = 'rgba(26, 46, 26, 0.95)';
                this.ctx.fillRect(panelX, panelY, panelWidth, panelHeight);
                this.ctx.strokeStyle = '#00ff00';
                this.ctx.lineWidth = 3;
                this.ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);
                
                this.ctx.fillStyle = '#00ff00';
                this.ctx.font = 'bold ' + Math.floor(panelHeight * 0.12) + 'px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText('üèÜ VICTORY!', centerX, panelY + panelHeight * 0.15);
                
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = Math.floor(panelHeight * 0.06) + 'px Arial';
                const statsY = panelY + panelHeight * 0.35;
                const lineHeight = panelHeight * 0.08;
                
                this.ctx.fillText('Final Score: ' + this.score, centerX, statsY);
                this.ctx.fillText('Obstacles Dodged: ' + this.dodgedCount, centerX, statsY + lineHeight);
                this.ctx.fillText('Survival Time: ' + this.formatTime(this.finalSurvivalTime), 
                                 centerX, statsY + lineHeight * 2);
                this.ctx.fillText('Health Remaining: ' + Math.round(this.player.health), 
                                 centerX, statsY + lineHeight * 3);
                
                if (this.player.health === 100) {
                    this.ctx.fillStyle = '#ffff00';
                    this.ctx.font = 'bold ' + Math.floor(panelHeight * 0.08) + 'px Arial';
                    this.ctx.fillText('‚≠ê PERFECT RUN! ‚≠ê', centerX, statsY + lineHeight * 4);
                }
                
                const againBtn = this.ui.drawButton(centerX - 120, panelY + panelHeight * 0.72, 
                                                    240, 50, 'Play Again', false);
                this.interactiveElements.againBtn = {
                    ...againBtn,
                    type: 'button',
                    callback: () => this.restartGame()
                };
                
                const menuBtn = this.ui.drawButton(centerX - 120, panelY + panelHeight * 0.84, 
                                                   240, 50, 'Choose New Song', false);
                this.interactiveElements.menuBtn3 = {
                    ...menuBtn,
                    type: 'button',
                    callback: () => this.returnToMenu()
                };
            }

            gameLoop() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }

            gameOver() {
                this.isRunning = false;
                this.currentScreen = 'gameover';
                this.audio.pause();
                this.finalSurvivalTime = (Date.now() - this.gameStartTime - this.totalPausedTime) / 1000;
                this.updateMobileControlsVisibility();
                
                // Allow portrait orientation in game over screen
                this.unlockOrientation();
            }

            victory() {
                this.isRunning = false;
                this.currentScreen = 'victory';
                this.audio.pause();
                this.finalSurvivalTime = (Date.now() - this.gameStartTime - this.totalPausedTime) / 1000;
                this.updateMobileControlsVisibility();
                
                // Allow portrait orientation in victory screen
                this.unlockOrientation();
            }

            reset() {
                this.player.x = 100;
                this.player.y = this.height / 2;
                this.player.health = 100;
                this.player.isDashing = false;
                this.player.dashCooldown = 0;
                this.player.dashDuration = 0;
                this.obstacles = [];
                this.score = 0;
                this.dodgedCount = 0;
                this.gameTime = 0;
                this.isPaused = false;
                this.totalPausedTime = 0;
                this.pauseStartTime = 0;
                this.keys = {};
                this.healthRegenTimer = 0;
            }

            restartGame() {
                this.reset();
                this.loadObstacles([...this.originalObstacles]);
                const audio = new Audio(URL.createObjectURL(this.audioFile));
                this.start(audio);
            }

            returnToMenu() {
                if (this.audio) {
                    this.audio.pause();
                }
                this.isRunning = false;
                this.isPaused = false;
                this.currentScreen = 'menu';
                this.statusMessage = '';
                this.loadingProgress = undefined;
                this.totalPausedTime = 0;
                this.pauseStartTime = 0;
                this.updateMobileControlsVisibility();
                
                // Allow portrait orientation in menu
                this.unlockOrientation();
            }

            openFileDialog() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'audio/*';
                input.onchange = (e) => this.handleFileUpload(e);
                input.click();
            }

            async handleFileUpload(e) {
                const file = e.target.files[0];
                if (!file) return;

                this.audioFile = file;
                
                try {
                    this.statusMessage = 'Loading audio file...';
                    this.statusColor = '#00ffff';
                    this.loadingProgress = 0.2;
                    
                    const arrayBuffer = await file.arrayBuffer();
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    this.statusMessage = 'Decoding audio...';
                    this.loadingProgress = 0.4;
                    
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    
                    this.statusMessage = 'Analyzing rhythm and generating obstacles...';
                    this.loadingProgress = 0.6;
                    
                    const beatDetector = new EnhancedBeatDetector();
                    const obstacles = await beatDetector.analyzeAudio(audioBuffer);
                    
                    const laserCount = obstacles.filter(o => o.type === 'laser').length;
                    const squareCount = obstacles.filter(o => o.type === 'square').length;
                    const triangleCount = obstacles.filter(o => o.type === 'triangle').length;
                    
                    this.statusMessage = `Found ${obstacles.length} obstacles! ` +
                        `(üî¥ ${laserCount} lasers, üîµ ${squareCount} squares, üî∫ ${triangleCount} triangles)`;
                    this.loadingProgress = 0.8;
                    
                    this.originalObstacles = obstacles;
                    
                    setTimeout(() => {
                        this.loadingProgress = 1.0;
                        this.statusColor = '#00ff00';
                        this.loadingProgress = undefined;
                        
                        this.pendingAudio = new Audio(URL.createObjectURL(file));
                        this.pendingObstacles = [...obstacles];
                    }, 800);
                    
                } catch (error) {
                    this.statusMessage = '‚ùå Error: ' + error.message;
                    this.statusColor = '#ff0000';
                    this.loadingProgress = undefined;
                    console.error('Error processing audio:', error);
                }
            }
        }

        // ==================== MAIN APPLICATION ====================
        const canvas = document.getElementById('gameCanvas');
        const game = new RhythmRunner(canvas);
        game.gameLoop();
    </script>
</body>
</html>
